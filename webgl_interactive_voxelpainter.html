<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive - voxel painter</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}

			#oldie { background-color: #ddd !important }
            
            #dropdown{
                width:200px;
                background:#222;
                margin:20px;
            }

            #dropdown li{
                font-family:sans-serif;
              padding:3px 10px 3px 30px;
               color:white;
                cursor:pointer;
            }
            #dropdown li:hover{
                background-color:blue !important;
            }

            #dropdown li.checked{
                background:url(http://cdn1.iconfinder.com/data/icons/fatcow/16x16_0020/accept.png) 0 5px no-repeat;
            }
            
            #gui { position: absolute; top: 60px; left: 85% }

            
		</style>
	</head>
	<body>
        
         
         

        
		<script src="libs/three.min.js"></script>

		<script src="js/Detector.js"></script>
        <script src="libs/TrackballControls.js"></script>
        <script src="js/controls/OrbitControls.js"></script>
        <script src='js/libs/dat.gui.min.js'></script>
        <script src='gui.js'></script>
    

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
            
            var clock = new THREE.Clock();
			var container;
            var controls;
            var isMouseDown = false, isMouseMove = false;
			var camera, scene, renderer;
			var plane, cube;
			var mouse, raycaster, isShiftDown = false;

			var rollOverMesh, rollOverMaterial;
			var cubeGeo, cubeMaterial;
            var objArray;
            var currBlockType = 0;
            var spawnBlock;
            
            var t = THREE;
            var materials = [
                                 new t.MeshLambertMaterial({/*color: 0x00CCAA,*/map: t.ImageUtils.loadTexture('textures/white-bricks.jpg')}),
                                 new t.MeshLambertMaterial({/*color: 0xC5EDA0,*/map: t.ImageUtils.loadTexture('images/ground.jpg')}),
                                new t.MeshLambertMaterial({/*color: 0xC5EDA0,*/map: t.ImageUtils.loadTexture('images/wood.jpg')}),
                                new t.MeshLambertMaterial({/*color: 0xC5EDA0,*/map: t.ImageUtils.loadTexture('images/stone.png')}), 
                                new t.MeshLambertMaterial({color: 0xFBEBCD})
                                 ];

			var objects = [];
            
            var block = {
                BRICK : 0,
                GROUND : 1,
                WOOD : 2,
                STONE : 3,
                SPAWN : 4
                
            };
            
             
			init();
			render();
            
            
            
            
           
            
            function createArray(length)
            {
                var arr = new Array(length || 0),
                    i = length;

                if (arguments.length > 1) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    while(i--) arr[length-1 - i] = createArray.apply(this, args);
                }

                return arr;
            }
            
            function openWindow()
            {
                saveJSON(false);
                window.open('file2.html');
            }
            
            function createButton(name, text, width, height, top, left)
            {
                var button = document.createElement("BUTTON");
                var buttonText = document.createTextNode(text);
                button.appendChild(buttonText);

                button.style.position = 'absolute';
                button.tagName = name;

                button.style.width = width;
                button.style.height = height;
                button.style.top = window.innerHeight/2 + top + 'px';
                button.style.left = window.innerWidth/2 + left + 'px';
                document.body.appendChild(button);

                return button;
            }
            
            
            
			function init() {
                mouseTemp = new THREE.Vector2(0, 0);
                container = document.createElement( 'div' );
				document.body.appendChild( container );
                
               // objArray = createArray(30, 30, 30);
                objArray = [];
				

				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> - voxel painter - webgl<br><strong>click</strong>: add voxel, <strong>shift + click</strong>: remove voxel';
				container.appendChild( info );
                
                var link = document.createElement( 'div');
                link.innerHTML = '<a href="javascript:openWindow();">CLICK ME</a>';
                container.appendChild(link);
                
                
                
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 500, 800, 1300 );
				camera.lookAt( new THREE.Vector3() );

				scene = new THREE.Scene();

				// roll-over helpers

				rollOverGeo = new THREE.BoxGeometry( 50, 50, 50 );
				rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
				rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
				scene.add( rollOverMesh );
                
                var axis = new THREE.AxisHelper();
                scene.add(axis);
                

				// cubes

				cubeGeo = new THREE.BoxGeometry( 50, 50, 50 );
				cubeMaterial = materials[block.SPAWN];
                
                spawnBlock = new t.Mesh(cubeGeo, cubeMaterial);

                spawnBlock.type = block.SPAWN;
                
                scene.add(spawnBlock);
                objects.push(spawnBlock);
                
				// grid

				var size = 1000, step = 50;

				var geometry = new THREE.Geometry();

				for ( var i = - size; i <= size; i += step ) {

					geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
					geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );

					geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
					geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );

				}

				var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2, transparent: true } );

				var line = new THREE.LineSegments( geometry, material );
				scene.add( line );

				//

				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();

				var geometry = new THREE.PlaneBufferGeometry( 2000, 2000 );
				geometry.rotateX( - Math.PI / 2 );

				plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
				scene.add( plane );

				objects.push( plane );

				// Lights

				var ambientLight = new THREE.AmbientLight( 0x606060 );
				scene.add( ambientLight );

				var directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.set( 1, 1.75, 0.5 ).normalize();
				scene.add( directionalLight );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
                
                // controls
                controls = new THREE.OrbitControls(camera);
                controls.target.set(0,0,0);
                
                // gui
                
                setUpGui();
                
                
                
                //stats = new Stats();
				//stats.domElement.style.position = 'absolute';
				//stats.domElement.style.top = '0px';
				//container.appendChild( stats.domElement );


				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'keydown', onDocumentKeyDown, false );
				document.addEventListener( 'keyup', onDocumentKeyUp, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp, false );
                document.addEventListener( 'mousewheel', onDocumentWheel, false);
                document.addEventListener( 'drop', onDrop, false);
                document.addEventListener( 'dragover', onDragOver, false);
                
                // Buttons
                
                var exportButton = createButton("export", "Export Map", 50, 50, -window.innerHeight/2 + 25, window.innerWidth/2 - 125);
                exportButton.addEventListener('click', onExportClick);
                
                var clearButton = createButton("clear", "Clear Map", 50, 50, -window.innerHeight/2 + 25, window.innerWidth/2 - 250);
                clearButton.addEventListener('click', clearScreen);
                
                document.addEventListener( )
                

				//
                
                //update();

				window.addEventListener( 'resize', onWindowResize, false );

			}
            
            /*
            function update()
            {
                for (var property in color)
                {
                    if (color.property == 
                }
                requestAnimationFrame(update);
            }
            */
            
            function onExportClick()
            {
                //var jsonArray = JSON.parse(JSON.stringify(objArray));
                
                saveJSON(true);
                
                //console.log(jsonArray.toString);
                
            }
            
            function onDragOver(event)
            {
                event.preventDefault();
            }
            
            function onDocumentWheel( event )
            {
                event.preventDefault();
                render();
                //controls.update();
            }

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				//event.preventDefault();

                
				
                mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
                
                mouseTemp.x += mouse.x;
                mouseTemp.y += mouse.y;
                
                isMouseMove = true;
                
				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );
                
                console.log(intersects.length);

				if ( intersects.length > 0 ) {

					var intersect = intersects[ 0 ];
                    //rollOverMesh.visibility = false;

					rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );
					rollOverMesh.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
                    
                
                    

				}

				render();

			}

            var mouseTemp;
			function onDocumentMouseDown( event ) {

				event.preventDefault();
                
                isMouseDown = true;
                isMouseMove = false;
                
                mouseTemp = new THREE.Vector2(0, 0);

				

			}
            
            function onDocumentMouseUp( event ) {
                
                event.preventDefault();
                isMouseDown = false;
                
                mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );
                
                //console.log(mouseTemp.length())

				if ( intersects.length > 0 ) {

					var intersect = intersects[ 0 ];

					// delete cube

					if ( isShiftDown ) {

						if ( intersect.object != plane && intersect.object != spawnBlock ) {

							scene.remove( intersect.object );

							objects.splice( objects.indexOf( intersect.object ), 1 );

						}

					// create cube
                        
					} else {
                        if (mouseTemp.length() <= 3)
                        {
                            if (currBlockType == block.SPAWN)
                            {
                                scene.remove(spawnBlock)
                                objects.splice(objects.indexOf(spawnBlock), 1);
                                
                                spawnBlock = new THREE.Mesh( cubeGeo, materials[currBlockType] );
                                spawnBlock.type = 4;
                                
                                spawnBlock.position.copy( intersect.point ).add( intersect.face.normal );
                                //console.log(voxel.position);

                                spawnBlock.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
                            
                                //console.log(voxel.position);
                                scene.add( spawnBlock );
                                objects.push(spawnBlock);
                                rollOverMesh.visible = false;
                            }
                            else{
                                
                                var voxel = new THREE.Mesh( cubeGeo, materials[currBlockType] );
                                voxel.type = currBlockType;
                                //console.log(intersect.face.normal);
                                //console.log(intersect.point);
                                //console.log(intersect.point.add(intersect.face.normal));
                                voxel.position.copy( intersect.point ).add( intersect.face.normal );
                                //console.log(voxel.position);

                                voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );

                                //console.log(voxel.position);
                                scene.add( voxel );

                                objects.push( voxel );
                                objArray.push(voxel);
                                rollOverMesh.visible = false;
                            }
                        }

					}

					//render();

				}
            }

			function onDocumentKeyDown( event ) {

				switch( event.keyCode ) {

					case 16: isShiftDown = true; color.red = false; break;

				}
                
                render();

			}

			function onDocumentKeyUp( event ) {

				switch ( event.keyCode ) {

					case 16: isShiftDown = false; break;

				}
                render();

			}
            
            function onDrop(event) {
				event.preventDefault();
				for(var i = 0; i < event.dataTransfer.files.length; i++){
					var file	= event.dataTransfer.files[i];
					var reader	= new FileReader();
					reader.onload = function (event){
						var dataUri	= event.target.result;
						var base64	= dataUri.match(/[^,]*,(.*)/)[1];
						var json	= window.atob(base64);
						loadJSON( json )
					};
					reader.readAsDataURL(file);
				}
			}
            var voxels;
            
            function saveJSON(openWindow) {
				var children	= scene.children;
				 voxels	= [];
				for( var i = 0; i < children.length; i++ ) {
					var child	= children[i];
					if( child instanceof THREE.Mesh === false )			continue;
					if( child.geometry instanceof THREE.CubeGeometry === false )	continue;
					if( child === rollOverMesh )					continue;
					voxels.push({
						x	: (child.position.x - 25) / 50,
						y	: (child.position.y - 25) / 50,
						z	: (child.position.z - 25) / 50,
						t	: child.type
					});
				}
				
				// open a window with the json
                
                if (openWindow)
                {
                    var dataUri	= "data:application/json;charset=utf-8,"+JSON.stringify(voxels);
                    window.open( dataUri, 'mywindow' );
                }
			}
            
            function loadJSON(mapJSON) {
				// delete all cubes
				var children	= scene.children.slice(0);
				for( var i = 0; i < children.length; i++ ) {
					if( children[i] instanceof THREE.Mesh === false ) continue;
					if( children[i].geometry instanceof THREE.CubeGeometry === false ) continue;
					if( children[i] === rollOverMesh ) continue;
                    
                    objects.splice(objects.indexOf(children[i]), 1);
					scene.remove( children[i] );
                    
				}				
				// push new cubes
                voxels = [];
                voxels	= JSON.parse(mapJSON);
				for( var i = 0; i < voxels.length; i++ ){
					var voxel = voxels[i];
					var mesh = new THREE.Mesh( cubeGeo, materials[voxel.t] );
					mesh.position.x = voxel.x * 50 + 25;
					mesh.position.y = voxel.y * 50 + 25;
					mesh.position.z = voxel.z * 50 + 25;
                    mesh.type = voxel.t;
					mesh.matrixAutoUpdate = true;
					mesh.updateMatrix();
					scene.add( mesh );
                    objects.push(mesh);
					
				}
			}
            
            function clearScreen()
            {
                // delete all cubes
				var children	= scene.children.slice(0);
				for( var i = 0; i < children.length; i++ ) {
					if( children[i] instanceof THREE.Mesh === false ) continue;
					if( children[i].geometry instanceof THREE.CubeGeometry === false ) continue;
					if( children[i] === rollOverMesh ) continue;
                    if( children[i] === spawnBlock) continue;
                    
                    objects.splice(objects.indexOf(children[i]), 1);
					scene.remove( children[i] );
                    
				}		
            }

			function render() {
                
                var delta = clock.getDelta();
                controls.update();
                
                
                //console.log(isShiftDown);
                
                if (isShiftDown)
                    rollOverMesh.visible = false;
                else
                    rollOverMesh.visible = true;

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
