<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive - voxel painter</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
                
				
				margin: 0px;
				overflow: hidden;
			}
            

			#oldie { background-color: #ddd !important }
            
            #instructions {
				width: 100%;
				height: 100%;
				display: -webkit-box;
				display: -moz-box;
				display: box;
				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;
				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;
				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;
				color: #000000;
				text-align: center;
				cursor: pointer;
			}
            
		</style>
	</head>
	<body>
        
         
        
		<script src="libs/three.min.js"></script>
        
        <script src='js/libs/dat.gui.min.js'></script>
        <script src='js/renderers/Projector.js'></script>
        <script src='Three.FirstPersonControls.js'></script>
        <script src='js/controls/PointerLockControls.js'></script>
        <script src='libs/cannon.min.js'></script>
        <script src='jquery-1.7.2.min.js'></script>
        <script src="libs/physi.js"></script>


        <div id="blocker">

			<div id="instructions">
				<span style="font-size:40px">Click to play</span>
				<br />
				(W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
			</div>

		</div>
        
		<script>

			//if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
            
            var clock = new THREE.Clock();
			var container;
            
            var isMouseDown = false, isMouseMove = false;
			var camera, renderer;
			var plane, cube;
			var raycaster, isShiftDown = false;
            var raycasterposX, raycasternegX, raycasterposZ, raycasternegZ;

			var rollOverMesh, rollOverMaterial;
			var cubeGeo, cubeMaterial;
            var objArray;

			var objects = [];
            
            var WIDTH = window.innerWidth,
            HEIGHT = window.innerHeight,
            ASPECT = WIDTH / HEIGHT,
            UNITSIZE = 250,
            WALLHEIGHT = UNITSIZE / 3,
            MOVESPEED = 100,
            LOOKSPEED = 0.075,
            BULLETMOVESPEED = MOVESPEED * 5,
            NUMAI = 5,
            PROJECTILEDAMAGE = 20;
            
            // Global vars
            var t = THREE, scene, cam, renderer, controls, projector, model, skin;
            var p = Physijs;
            var runAnim = true, mouse = { x: 0, y: 0 }, kills = 0, health = 100;
            var healthCube, lastHealthPickup = 0;
            var mapW = 1000, mapH = 1000;
            var timeStep;
            
            var world;
            var meshArray = [];
            var bodyArray = [];
            
            var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;
            
            var controlsEnabled = false;
            
            var prevTime = performance.now();
			var velocity = new THREE.Vector3();
            
            var materials = [
                                 new t.MeshLambertMaterial({/*color: 0x00CCAA,*/map: t.ImageUtils.loadTexture('textures/white-bricks.jpg')}),
                                 new t.MeshLambertMaterial({/*color: 0xC5EDA0,*/map: t.ImageUtils.loadTexture('images/ground.jpg')}),
                                new t.MeshLambertMaterial({/*color: 0xC5EDA0,*/map: t.ImageUtils.loadTexture('images/wood.jpg')}),
                                new t.MeshLambertMaterial({/*color: 0xC5EDA0,*/map: t.ImageUtils.loadTexture('images/stone.png')}),
                                 new t.MeshLambertMaterial({color: 0xFBEBCD}),
                                 ];
            
            var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
			if ( havePointerLock ) {
				var element = document.body;
				var pointerlockchange = function ( event ) {
					if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
						controlsEnabled = true;
						controls.enabled = true;
					} else {
						controls.enabled = false;
						console.log("This doesn't work");
                        instructions.style.display = 'initial';
					}
				};
                
                var pointerlockerror = function ( event ) {
					instructions.style.display = '';
				};
                
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
				document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
				document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
                
                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
				document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
				document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
                
                instructions.addEventListener( 'click', function ( event ) {
					instructions.style.display = 'none';
					// Ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
					if ( /Firefox/i.test( navigator.userAgent ) ) {
						var fullscreenchange = function ( event ) {
							if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
								document.removeEventListener( 'fullscreenchange', fullscreenchange );
								document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
								element.requestPointerLock();
							}
						};
						document.addEventListener( 'fullscreenchange', fullscreenchange, false );
						document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
						element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
						element.requestFullscreen();
					} else {
						element.requestPointerLock();
					}
				}, false );
                
            }
            else
                console.log("This doesn't work 2");
            
            
            
            
            // Editor Variables////
            
            
            var editor= {voxelArray: window.opener.voxels,
                          spawnPoint: window.opener.spawnBlock.position};
            
            var block = window.opener.block;
            
            Physijs.scripts.worker = 'libs/physijs_worker.js';
            Physijs.scripts.ammo = 'ammo.js';
            
			init();
			//render();
            
            
            
            var playerObject;
			function init() {
                mouseTemp = new THREE.Vector2(0, 0);
                container = document.createElement( 'div' );
				document.body.appendChild( container );
                
               // objArray = createArray(30, 30, 30);
                objArray = [];
				
                projector = new t.Projector(); // Used in bullet projection
                
				
                scene = new p.Scene();
                scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
                scene.addEventListener('update', function() 
                {
                    scene.simulate();
                });
                
				// Set up camera
                cam = new t.PerspectiveCamera(60, ASPECT, 1, 10000); // FOV, aspect, near, far
                cam.position.y = 25;
                
                
                scene.add(cam);

				
                
                scene.fog = new t.FogExp2(0xD6F1FF, 0.0005); // color, density
                
                // Camera moves with mouse, flies around with WASD/arrow keys
                
        
                controls = new THREE.PointerLockControls( cam );
                controls.getObject().position.x = editor.spawnPoint.x;
                controls.getObject().position.z = editor.spawnPoint.z;
				scene.add( controls.getObject() );
                
                controls.moveForward = false;
                controls.moveBackward = false;
                controls.moveLeft = false;
                controls.moveRight = false;
                
                controls.move = function(moveDir) {
                    this.moveForward = false;
                    this.moveBackward = false;
                    this.moveLeft = false;
                    this.moveRight = false;
                    
                    switch (moveDir)
                    {
                        case 'forward':
                            this.moveBackward = true;
                            break;
                        case 'backward':
                            this.moveBackward = true;
                            break;
                        case 'left':
                            this.moveLeft = true;
                            break;
                        case 'right':
                            this.moveRight = true;
                            break;
                    }
                }
                
                var axis = new THREE.AxisHelper();
                scene.add(axis);
            
                

				// cubes

				cubeGeo = new THREE.BoxGeometry( 50, 50, 50 );
				cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xfeb74c, shading: THREE.FlatShading, map: THREE.ImageUtils.loadTexture( "textures/white-bricks.jpg" ) } );
                
                // tie physijs object to camera
                
                
                playerObject = new p.BoxMesh(cubeGeo,
                                        new p.createMaterial(new t.MeshBasicMaterial({color:'green'}), .4, .8) );
                
                //playerObject.position.y += 100;
                
                //scene.add(playerObject);
                
                //controls.getObject().add(playerObject);
                
                // Set up raycaster for jumping
                raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );
                
                // raycasters for collision detection
                raycasterposX =  new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 1,  0, 0 ), 0, 10 );
                raycasternegX =  new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( -1, 0, 0 ), 0, 10 );
                raycasterposZ =  new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, 0, 1 ), 0, 10 );
                raycasternegZ =  new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, 0, -1 ), 0, 10 );
                
                
                setupScene();

				// Lights

				var ambientLight = new THREE.AmbientLight( 0x606060 );
				scene.add( ambientLight );

				var directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.set( 1, 1.75, 0.5 ).normalize();
				scene.add( directionalLight );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				
				renderer.setSize( window.innerWidth, window.innerHeight );
                //renderer.domElement.style.backgroundColor = '#D6F1FF';
                renderer.setClearColor( 0xD6F1FF );
				container.appendChild( renderer.domElement );
            
                
                //stats = new Stats();
				//stats.domElement.style.position = 'absolute';
				//stats.domElement.style.top = '0px';
				//container.appendChild( stats.domElement );


				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'keydown', onDocumentKeyDown, false );
				document.addEventListener( 'keyup', onDocumentKeyUp, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp, false );
                //document.addEventListener( 'mousewheel', onDocumentWheel, false);
                //document.addEventListener( 'drop', onDrop, false);
                //document.addEventListener( 'dragover', onDragOver, false);
                
                
                
                
                

				//

				//window.addEventListener( 'resize', onWindowResize, false );
                scene.simulate();
                render();

			}
            
            // Set up the objects in the world
            var cannonShape, cannonBody, body;
            function setupScene() {
                //meshArray.push(5);
                var UNITSIZE = 250,  units = mapW;
                
                
                
                
                // skybox
                var urlPrefix = "textures/";
                var urls = [ urlPrefix + "calm_right.jpg", urlPrefix + "calm_left.jpg",
                    urlPrefix + "calm_top.jpg", urlPrefix + "calm_top.jpg",
                    urlPrefix + "calm_front.jpg", urlPrefix + "calm_back.jpg"];
                var textureCube = THREE.ImageUtils.loadTextureCube( urls );

                var shader = THREE.ShaderLib["cube"];
                var uniforms = THREE.UniformsUtils.clone( shader.uniforms );
                uniforms['tCube'].value = textureCube;   // textureCube has been init before
                
                var material = new THREE.ShaderMaterial({
                    fragmentShader    : shader.fragmentShader,
                    vertexShader  : shader.vertexShader,
                    uniforms  : uniforms,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });
                
                // build the skybox Mesh 
                skyboxMesh    = new THREE.Mesh( new THREE.BoxGeometry( 10000, 10000, 10000, 1, 1, 1), material );
                // add it to the scene
                scene.add( skyboxMesh );
                


                // Geometry: floor
                var floor = new p.BoxMesh(
                        new t.CubeGeometry(2000, 0, 2000),
                        new p.createMaterial( new t.MeshLambertMaterial({map: t.ImageUtils.loadTexture('images/ground.jpg')}), .4, .8 ), 0
                );
                scene.add(floor);
                objects.push(floor);
                
                
        
                // Geometry: walls
                var cube = new t.CubeGeometry(50, 50, 50);
                
                
                for( var i = 0; i < editor.voxelArray.length; i++ ){
					var voxel = editor.voxelArray[i];
					
                    if (voxel.t != block.SPAWN)
                    {
                        var mesh = new p.BoxMesh( cube, new p.createMaterial(materials[voxel.t], .4, .8) ) ;

                        mesh.position.x = voxel.x * 50 + 25;
                        mesh.position.y = voxel.y * 50 + 25;
                        mesh.position.z = voxel.z * 50 + 25;
                        mesh.matrixAutoUpdate = true;
                        mesh.updateMatrix();
                        meshArray.push(mesh);
                        scene.add( mesh );
                        objects.push(mesh);
                    }
                    
					
                } // end for

                
            } // end function
            
            

			
           
            
            var mouseTemp;
			function onDocumentMouseDown( event ) {

				event.preventDefault();
                
                

				

			}
            
            function onDocumentMouseUp( event ) {
                
                event.preventDefault();
                
               

				
            }

			function onDocumentKeyDown( event ) {
                
				switch ( event.keyCode ) {
						case 38: // up
						case 87: // w
                            controls.move('forward');
							moveForward = true;
							break;
						case 37: // left
						case 65: // a
                            controls.move('left');
							moveLeft = true; break;
						case 40: // down
						case 83: // s
                            controls.move('backward');
							moveBackward = true;
							break;
						case 39: // right
						case 68: // d
                            controls.move('right');
							moveRight = true;
							break;
						case 32: // space
							if ( canJump === true ) velocity.y += 350;
							canJump = false;
							break;
					}
                
                //render();

			}

			function onDocumentKeyUp( event ) {
                switch( event.keyCode ) {
						case 38: // up
						case 87: // w
							moveForward = false;
							break;
						case 37: // left
						case 65: // a
							moveLeft = false;
							break;
						case 40: // down
						case 83: // s
							moveBackward = false;
							break;
						case 39: // right
						case 68: // d
							moveRight = false;
							break;
					}

               // render();

			}
            
          


			function render() {
                
                //var delta = clock.getDelta(), speed = delta * BULLETMOVESPEED;
                //var aispeed = delta * MOVESPEED;
                //controls.update(delta); // Move camera
                
                if ( controlsEnabled ) {
                   
					raycaster.ray.origin.copy( controls.getObject().position );
					raycaster.ray.origin.y -= 10;
					var intersections = raycaster.intersectObjects( objects );
					var isOnObject = intersections.length > 0;
					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;
					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;
					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
                    
                    //console.log(isOnObject);
                    
                    //console.log(moveForward);
                    
                    //console.log(controls.getDirection(new THREE.Vector3(0,0,0) ) );
                    
                    
					if ( moveForward ) velocity.z -= 1000.0 * delta;
					if ( moveBackward ) velocity.z += 1000.0 * delta;
					if ( moveLeft ) velocity.x -= 1000.0 * delta;
					if ( moveRight ) velocity.x += 1000.0 * delta;
					if ( isOnObject === true ) {
						velocity.y = Math.max( 0, velocity.y );
                        //controls.getObject().position.y = intersections[0].position.y;
						canJump = true;
					}
                    
                    //console.log(velocity);
                    
                    //console.log(controls.moveForward());
                    
					controls.getObject().translateX( velocity.x * delta );
					controls.getObject().translateY( velocity.y * delta );
					controls.getObject().translateZ( velocity.z * delta );
                    
                    /*
                    console.log(controls.getObject().rotation.y);
                    console.log(controls.getObject().rotation.x);
                    console.log(controls.getObject().rotation.z);
                    console.log("Player: " + playerObject.rotation.y);
                    console.log(playerObject.rotation.x);
                    console.log(playerObject.rotation.z);
                    */
                    //playerObject.translateX(velocity.x * delta);
                   // playerObject.translateY(velocity.y * delta);
                    //playerObject.translateZ(velocity.z * delta);
                    
                    console.log(controls.moveLeft);
                    
					if ( controls.getObject().position.y < 10 ) {
						velocity.y = 0;
						controls.getObject().position.y = 10;
						canJump = true;
					}
					prevTime = time;
				}
                
                // Step the physics world
               // console.log(body.position + "this is the first body position before world step");
		          
                
                //console.log(body.position + "this is the first body position");
                for (var i = 0; i < bodyArray.length; i++)
                {
                    //console.log(bodyArray[0]);
                    bodyArray[i].mesh.position.copy(bodyArray[i].position);
                    bodyArray[i].mesh.quaternion.copy( bodyArray[i].quaternion );
                    
                    
                }
                
                

                requestAnimationFrame( render );
				renderer.render( scene, cam );

			}
            
            
            /*
            function detectCollision() {
               // unlockAllDirection();

                var rotationMatrix;
                var cameraDirection = controls.getDirection(new THREE.Vector3(0, 0, 0)).clone();

                if (controls.moveForward()) {
                    // Nothing to do!
                }
                else if (controls.moveBackward()) {
                    rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeRotationY(180 * Math.PI / 180);
                }
                else if (controls.moveLeft()) {
                    rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeRotationY(90 * Math.PI / 180);
                }
                else if (controls.moveRight()) {
                    rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeRotationY((360-90) * Math.PI / 180);
                }
                else return;

                if (rotationMatrix !== undefined){
                    cameraDirection.applyMatrix4(rotationMatrix);
                }
                var rayCaster = new THREE.Raycaster(controls.getObject().position, cameraDirection);    
                var intersects = rayCaster.intersectObject(hitMesh, true);  

                $("#status").html("camera direction x: " + cameraDirection.x + " , z: " + cameraDirection.z);

                if ((intersects.length > 0 && intersects[0].distance < 25)) {
                    //lockDirection();
                    
                }
            }
            */
            
            
            
            function onDocumentMouseMove(e) {
                e.preventDefault();
                mouse.x = (e.clientX / WIDTH) * 2 - 1;
                mouse.y = - (e.clientY / HEIGHT) * 2 + 1;
            }

            // Handle window resizing
            $(window).resize(function() {
                WIDTH = window.innerWidth;
                HEIGHT = window.innerHeight;
                ASPECT = WIDTH / HEIGHT;
                if (cam) {
                    cam.aspect = ASPECT;
                    cam.updateProjectionMatrix();
                }
                if (renderer) {
                    renderer.setSize(WIDTH, HEIGHT);
                }
                //$('#intro, #hurt').css({width: WIDTH, height: HEIGHT,});
            });

            // Stop moving around when the window is unfocused (keeps my sanity!)
            $(window).focus(function() {
                if (controls) controls.freeze = false;
            });
            $(window).blur(function() {
                if (controls) controls.freeze = true;
            });

            //Get a random integer between lo and hi, inclusive.
            //Assumes lo and hi are integers and lo is lower than hi.
            function getRandBetween(lo, hi) {
             return parseInt(Math.floor(Math.random()*(hi-lo+1))+lo, 10);
            }

		</script>

	</body>
</html>
